<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>GLB → Preview & STL (Three.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    :root { --side: 320px; }
    html, body { height: 100%; }
    body {
      margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, "Noto Sans JP", sans-serif;
      display: grid; grid-template-columns: var(--side) 1fr; height: 100%;
    }
    aside { padding: 16px; border-right: 1px solid #ddd; overflow: auto; }
    main { position: relative; background: #fff; }
    #viewport { position:absolute; inset:0; display:block; }
    fieldset { border: 1px solid #ccc; margin: 0 0 12px; padding: 10px; }
    legend { font-weight: 600; }
    label { display:block; margin: 6px 0 2px; }
    textarea, select, input[type="number"] { width: 100%; box-sizing: border-box; }
    button { width: 100%; padding: 10px; margin-top: 8px; }
    small { color:#666; }
    .row { display:flex; gap:8px; }
    .row > * { flex: 1; min-width: 0; }
    code { background: #f6f6f6; padding: 1px 4px; border-radius: 3px; }
  </style>

  <!-- Three.js を import map で解決 -->
  <script type="importmap">
  {
    "imports": {
      "three": "https://unpkg.com/three@0.164.0/build/three.module.js",
      "three/addons/": "https://unpkg.com/three@0.164.0/examples/jsm/"
    }
  }
  </script>
</head>
<body>
  <aside>
    <h2>GLB → STL（ブラウザ完結）</h2>

    <fieldset>
      <legend>.glb 読み込み</legend>
      <input id="glbFile" type="file" accept=".glb" />
      <button id="loadGlb">読み込んでプレビュー</button>
      <small>※ GLB はメッシュをそのまま読み込みます（色・材質は STL には反映されません）。</small>
    </fieldset>

    <fieldset>
      <legend>出力スケール（単位変換）</legend>
      <div class="row">
        <div>
          <label>GLB 1単位あたりの mm</label>
          <input id="mmPerUnit" type="number" value="1000" step="1" min="0.01"/>
        </div>
        <div>
          <label>全体スケール係数</label>
          <input id="uniformScale" type="number" value="1" step="0.01" min="0.01"/>
        </div>
      </div>
      <small>glTF は 1 単位 ≒ 1 m の運用が一般的です。STL は mm 想定のツールが多いため、既定では 1000 mm/単位 としています。</small>
    </fieldset>

    <div class="row">
      <button id="frameFit">フレーミング調整</button>
      <button id="export">STLを書き出し</button>
    </div>
    <small id="stats"></small>
  </aside>

  <main>
    <canvas id="viewport"></canvas>
  </main>

  <script type="module">
    /***** ライブラリ読み込み（import map を使用） *****/
    import * as THREE from 'three';
    import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
    import { GLTFLoader } from 'three/addons/loaders/GLTFLoader.js';
    import { STLExporter } from 'three/addons/exporters/STLExporter.js';
    import { mergeGeometries } from 'three/addons/utils/BufferGeometryUtils.js';

    /***** UI 参照 *****/
    const glbFileEl = document.getElementById('glbFile');
    const loadGlbBtn = document.getElementById('loadGlb');
    const mmPerUnitEl = document.getElementById('mmPerUnit');
    const uniformScaleEl = document.getElementById('uniformScale');
    const exportBtn = document.getElementById('export');
    const frameFitBtn = document.getElementById('frameFit');
    const statsEl = document.getElementById('stats');

    /***** Three.js セットアップ *****/
    const canvas = document.getElementById('viewport');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 10000);
    camera.position.set(3, 2.5, 3);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(1, 2, 1);
    scene.add(light1);
    scene.add(new THREE.AmbientLight(0xffffff, 0.5));

    const grid = new THREE.GridHelper(10, 10);
    grid.position.y = -0.01;
    scene.add(grid);

    // 表示用の親グループ（GLB をここに入れる）
    let meshGroup = new THREE.Group();
    scene.add(meshGroup);

    function resize() {
      const rect = canvas.parentElement.getBoundingClientRect();
      const ratio = Math.min(window.devicePixelRatio || 1, 2);
      renderer.setPixelRatio(ratio);
      renderer.setSize(rect.width, rect.height, false);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    (function animate(){
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    })();

    /***** カメラフレーミング（BBから自動算出） *****/
    function frameToObject(object, padding = 1.2) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3();
      box.getSize(size);
      const center = new THREE.Vector3();
      box.getCenter(center);

      const maxSize = Math.max(size.x, size.y, size.z) * padding;
      const fov = THREE.MathUtils.degToRad(camera.fov);
      const dist = maxSize / Math.tan(fov / 2);

      controls.target.copy(center);
      camera.position.copy(center).add(new THREE.Vector3(dist, dist * 0.75, dist));
      camera.near = Math.max(0.01, dist / 1000);
      camera.far = Math.max(2000, dist * 10);
      camera.updateProjectionMatrix();
    }

    /***** 情報表示 *****/
    function updateStats(object) {
      const box = new THREE.Box3().setFromObject(object);
      const size = new THREE.Vector3(); box.getSize(size);
      statsEl.textContent =
        `推定サイズ (scene units): ${size.x.toFixed(3)} × ${size.y.toFixed(3)} × ${size.z.toFixed(3)} / ` +
        `mm出力スケール: ${(Number(mmPerUnitEl.value) * Number(uniformScaleEl.value)).toFixed(2)} mm/unit`;
    }

    /***** GLB 読み込み *****/
    const loader = new GLTFLoader();
    loadGlbBtn?.addEventListener('click', async () => {
      const f = glbFileEl?.files?.[0];
      if (!f) { alert('.glb ファイルを選択してください。'); return; }

      const url = URL.createObjectURL(f);
      loader.load(url, (gltf) => {
        URL.revokeObjectURL(url);

        // 置き換え
        meshGroup.clear();
        meshGroup.add(gltf.scene);

        // マテリアルはプレビュー用（STLには反映されません）
        gltf.scene.traverse((obj) => {
          if (obj.isMesh && obj.material) {
            obj.material.metalness = 0.1;
            obj.material.roughness = 0.6;
          }
        });

        frameToObject(meshGroup, 1.3);
        updateStats(meshGroup);
      }, undefined, (err) => {
        URL.revokeObjectURL(url);
        console.error(err);
        alert('GLB の読み込みに失敗しました。コンソールをご確認ください。');
      });
    });

    frameFitBtn.addEventListener('click', () => {
      if (meshGroup.children.length === 0) return;
      frameToObject(meshGroup, 1.3);
      updateStats(meshGroup);
    });

    /***** STL 出力 *****/
    function exportSTL() {
      if (meshGroup.children.length === 0) {
        alert('先に GLB を読み込んでください。');
        return;
      }

      // すべてのメッシュのワールド変換を反映したジオメトリを収集
      const geoms = [];
      meshGroup.updateMatrixWorld(true);
      meshGroup.traverse(obj => {
        if (obj.isMesh && obj.geometry) {
          const g = obj.geometry.clone();
          g.applyMatrix4(obj.matrixWorld);
          geoms.push(g);
        }
      });
      if (geoms.length === 0) {
        alert('エクスポート対象のメッシュが見つかりません。');
        return;
      }

      // まとめて結合
      const merged = mergeGeometries(geoms, false);

      // 単位変換（scene units → mm）
      const mmPerUnit = Number(mmPerUnitEl.value || 1);
      const uniScale = Number(uniformScaleEl.value || 1);
      const scaleToMM = mmPerUnit * uniScale;

      if (scaleToMM !== 1) {
        const m = new THREE.Matrix4().makeScale(scaleToMM, scaleToMM, scaleToMM);
        merged.applyMatrix4(m);
      }

      // STL バイナリとして出力
      const exporter = new STLExporter();
      const stl = exporter.parse(new THREE.Mesh(merged), { binary: true });

      const blob = new Blob([stl], { type: 'model/stl' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'export_from_glb.stl';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    exportBtn.addEventListener('click', () => {
      try { exportSTL(); } catch (e) { console.error(e); alert('STL 書き出しに失敗しました。'); }
    });
  </script>
</body>
</html>
