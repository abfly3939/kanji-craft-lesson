<!doctype html>
<html lang="ja">
<head>
  <meta charset="utf-8" />
  <title>Kanji Blocks → STL (Three.js)</title>
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <style>
    body { margin: 0; font-family: system-ui, sans-serif; display: grid; grid-template-columns: 320px 1fr; height: 100vh; }
    aside { padding: 16px; border-right: 1px solid #ddd; overflow: auto; }
    main { position: relative; }
    #viewport { position:absolute; inset:0; }
    fieldset { border: 1px solid #ccc; margin: 0 0 12px; padding: 10px; }
    legend { font-weight: 600; }
    label { display:block; margin: 6px 0 2px; }
    textarea, select, input[type="number"] { width: 100%; box-sizing: border-box; }
    button { width: 100%; padding: 10px; margin-top: 8px; }
    small { color:#666; }
    .row { display:flex; gap:8px; }
    .row > * { flex: 1; }
  </style>
</head>
<body>
  <aside>
    <h2>漢字ブロック → STL</h2>

    <fieldset>
      <legend>入力データ</legend>
      <label>モード</label>
      <select id="mode">
        <option value="positions">ブロック座標（JSON配列）</option>
        <option value="bitmap">2Dビットマップ（文字列配列）</option>
      </select>

      <label>データ</label>
      <textarea id="input" rows="10" spellcheck="false">{
  "positions": [[0,0,0],[1,0,0],[2,0,0],[3,0,0],[0,1,0],[0,2,0],[3,1,0],[3,2,0],[0,3,0],[1,3,0],[2,3,0],[3,3,0]],
  "size": 1
}</textarea>
      <small>
        ・<b>座標モード</b>：<code>{"positions":[[x,y,z],...],"size":1}</code><br/>
        ・<b>ビットマップ</b>：<code>{"bitmap":["0110","1111","0110"],"z":0,"size":1}</code>（'1' がブロック）
      </small>
    </fieldset>

    <fieldset>
      <legend>プレビュー設定</legend>
      <div class="row">
        <div>
          <label>倍率</label>
          <select id="scale">
            <option value="0.25">1/4</option>
            <option value="0.5">1/2</option>
            <option value="1" selected>等倍</option>
            <option value="2">×2</option>
            <option value="4">×4</option>
          </select>
        </div>
        <div>
          <label>ボクセル基準サイズ（mm）</label>
          <input id="voxelSize" type="number" value="2" step="0.1" min="0.1"/>
        </div>
      </div>
      <small>STL は「(ボクセル基準サイズ × 倍率) mm」の立方体で出力します。</small>
    </fieldset>

    <div class="row">
      <button id="build">プレビューを更新</button>
      <button id="export">STLを書き出し</button>
    </div>
    <small id="stats"></small>
  </aside>

  <main>
    <canvas id="viewport"></canvas>
  </main>

  <script type="module">
    import * as THREE from 'https://unpkg.com/three@0.164.0/build/three.module.js';
    import { OrbitControls } from 'https://unpkg.com/three@0.164.0/examples/jsm/controls/OrbitControls.js';
    import { STLExporter } from 'https://unpkg.com/three@0.164.0/examples/jsm/exporters/STLExporter.js';
    import { mergeGeometries } from 'https://unpkg.com/three@0.164.0/examples/jsm/utils/BufferGeometryUtils.js';

    // ---------- UI ----------
    const modeEl = document.getElementById('mode');
    const inputEl = document.getElementById('input');
    const scaleEl = document.getElementById('scale');
    const voxelSizeEl = document.getElementById('voxelSize');
    const buildBtn = document.getElementById('build');
    const exportBtn = document.getElementById('export');
    const statsEl = document.getElementById('stats');

    // ---------- Three.js 基本セットアップ ----------
    const canvas = document.getElementById('viewport');
    const renderer = new THREE.WebGLRenderer({ canvas, antialias: true, alpha: true });
    const scene = new THREE.Scene();
    scene.background = new THREE.Color(0xffffff);

    const camera = new THREE.PerspectiveCamera(50, 1, 0.1, 1000);
    camera.position.set(80, 60, 80);

    const controls = new OrbitControls(camera, renderer.domElement);
    controls.enableDamping = true;

    const light1 = new THREE.DirectionalLight(0xffffff, 1);
    light1.position.set(1, 2, 1);
    scene.add(light1);
    scene.add(new THREE.AmbientLight(0xffffff, 0.4));

    const grid = new THREE.GridHelper(200, 20);
    grid.position.y = -0.01;
    scene.add(grid);

    let meshGroup = new THREE.Group();
    scene.add(meshGroup);

    // レイアウト
    function resize() {
      const rect = canvas.parentElement.getBoundingClientRect();
      renderer.setSize(rect.width, rect.height, false);
      camera.aspect = rect.width / rect.height;
      camera.updateProjectionMatrix();
    }
    window.addEventListener('resize', resize);
    resize();

    // アニメーション
    function animate() {
      requestAnimationFrame(animate);
      controls.update();
      renderer.render(scene, camera);
    }
    animate();

    // ---------- データ→メッシュ ----------
    function parseInput() {
      let data;
      try {
        data = JSON.parse(inputEl.value);
      } catch (e) {
        alert('JSON の構文エラーです。');
        throw e;
      }
      const mode = modeEl.value;

      if (mode === 'positions') {
        if (!Array.isArray(data.positions)) throw new Error('positions 配列が必要です');
        const size = Number(data.size ?? 1);
        return { type: 'positions', positions: data.positions, size };
      } else {
        if (!Array.isArray(data.bitmap)) throw new Error('bitmap 配列が必要です');
        const z = Number(data.z ?? 0);
        const size = Number(data.size ?? 1);
        // bitmap から positions を生成（(x,y,z)）
        const positions = [];
        for (let y = 0; y < data.bitmap.length; y++) {
          const row = String(data.bitmap[y]);
          for (let x = 0; x < row.length; x++) {
            if (row[x] === '1') positions.push([x, (data.bitmap.length - 1 - y), z]);
          }
        }
        return { type: 'bitmap', positions, size };
      }
    }

    function buildMesh() {
      // 既存をクリア
      meshGroup.clear();

      const { positions, size } = parseInput();
      const voxelBase = Number(voxelSizeEl.value || 1);
      const scale = Number(scaleEl.value || 1);
      const unit = voxelBase * scale; // mm 単位想定

      // Box をまとめて一個のジオメトリに結合（高速化）
      const half = unit / 2;
      const geoms = [];
      const box = new THREE.BoxGeometry(unit, unit, unit);
      for (const [x, y, z] of positions) {
        const g = box.clone();
        g.translate(x * unit + half, y * unit + half, z * unit + half);
        geoms.push(g);
      }
      if (geoms.length === 0) {
        alert('ブロックがありません。');
        return;
      }
      const merged = mergeGeometries(geoms, false);
      merged.computeBoundingBox();

      // マテリアルはプレビュー用（STL は形状のみ）
      const mesh = new THREE.Mesh(merged, new THREE.MeshStandardMaterial({ metalness: 0.1, roughness: 0.6 }));
      meshGroup.add(mesh);

      // カメラを自動で寄せる
      const bb = merged.boundingBox;
      const sizeV = new THREE.Vector3().subVectors(bb.max, bb.min);
      const center = new THREE.Vector3().addVectors(bb.min, bb.max).multiplyScalar(0.5);
      controls.target.copy(center);
      const radius = sizeV.length() * 0.6 + unit;
      camera.position.copy(center).add(new THREE.Vector3(radius, radius * 0.75, radius));
      camera.near = Math.max(0.1, unit * 0.1);
      camera.far = radius * 10 + unit;
      camera.updateProjectionMatrix();

      statsEl.textContent = `ブロック数: ${positions.length} / 立方体サイズ: ${unit.toFixed(2)} mm / 幅×奥行×高さ: ${sizeV.x.toFixed(2)} × ${sizeV.z.toFixed(2)} × ${sizeV.y.toFixed(2)} mm`;
    }

    function exportSTL() {
      if (meshGroup.children.length === 0) {
        alert('先にプレビューを生成してください。');
        return;
      }
      // 複数メッシュ対応：全体を 1 メッシュ化してから出力
      const allGeoms = [];
      meshGroup.traverse(obj => {
        if (obj.isMesh && obj.geometry) {
          const g = obj.geometry.clone();
          obj.updateMatrixWorld();
          g.applyMatrix4(obj.matrixWorld);
          allGeoms.push(g);
        }
      });
      const merged = mergeGeometries(allGeoms, false);
      const exporter = new STLExporter();
      const stl = exporter.parse(new THREE.Mesh(merged), { binary: true });

      const blob = new Blob([stl], { type: 'application/vnd.ms-pki.stl' });
      const a = document.createElement('a');
      a.href = URL.createObjectURL(blob);
      a.download = 'kanji_blocks.stl';
      a.click();
      URL.revokeObjectURL(a.href);
    }

    // 初期表示
    buildBtn.addEventListener('click', () => {
      try { buildMesh(); } catch (e) { console.error(e); }
    });
    exportBtn.addEventListener('click', () => {
      try { exportSTL(); } catch (e) { console.error(e); }
    });
    buildMesh();
  </script>
</body>
</html>
